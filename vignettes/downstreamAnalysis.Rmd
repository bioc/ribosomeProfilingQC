---
title: "ribosomeProfilingQC for downstream analysis"
author: "Jianhong Ou, Mariah Hoye"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('ribosomeProfilingQC')`"
bibliography: bibliography.bib
csl: nature.csl
vignette: >
  %\VignetteIndexEntry{ribosomeProfilingQC downstream analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---

```{r, echo=FALSE, results="hide", warning=FALSE, message=FALSE}
suppressPackageStartupMessages({
  library(ribosomeProfilingQC)
  library(BSgenome.Drerio.UCSC.danRer10)
  library(Rsamtools)
  library(AnnotationDbi)
  library(motifStack)
})
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

#Introduction

The `ribosomeProfilingQC` package can preprocess 
ribosome profiling data for subsequent differential analysis. 

Please note that all following analyses are based on known annotation.

# Input

The input of `ribosomeProfilingQC` is bam file. See [ribosomeProfilingQC]{ribosomeProfilingQC.html}

```{r}
library(Rsamtools)
## input the bamFile from the ribosomeProfilingQC package 
bamfilename <- system.file("extdata", "RPF.chr1.bam",
                           package="ribosomeProfilingQC")
## For your own data, please set bamfilename as your file path.
yieldSize <- 10000000
bamfile <- BamFile(bamfilename, yieldSize = yieldSize)
```

# Fragment Length Organization Similarity Score (FLOSS) [@ingolia2014ribosome]

FLOSS can be used to compare the distribution of reads length to a background such as a cluster of genes.
The gene cluster could be extracted from gtf/gff files downloaded from [ensembl](http://useast.ensembl.org/info/data/ftp/index.html).

```{r eval=FALSE}
## documentation: https://useast.ensembl.org/Help/Faq?id=468
gtf <- import("Danio_rerio.GRCz10.91.gtf.gz")
```
The gtf files can be also download via `AnnotationHub`

```{r eval=FALSE}
BiocManager::install("AnnotationHub")
library(AnnotationHub)
ah = AnnotationHub()
## for human hg38
hg38 <- query(ah, c("Ensembl", "GRCh38", "gtf"))
hg38 <- hg38[[length(hg38)]]
## for mouse mm10
mm10 <- query(ah, c("Ensembl", "GRCm38", "gtf"))
mm10 <- mm10[[length(mm10)]]
## because the gene ids in TxDb.Mmusculus.UCSC.mm10.knownGene and
## TxDb.Hsapiens.UCSC.hg38.knownGene
## are entriz_id, the gene_id in mm10 or hg38 need to changed to entriz_id.
library(ChIPpeakAnno)
library(org.Mm.eg.db)
mm10$gene_id <- ChIPpeakAnno::xget(mm10$gene_id, org.Mm.egENSEMBL2EG)
library(org.Hg.eg.db)
hg38$gene_id <- ChIPpeakAnno::xget(hg38$gene_id, org.Mm.egENSEMBL2EG)
```

```{r eval=FALSE}
gtf <- gtf[!is.na(gtf$gene_id)]
gtf <- gtf[gtf$gene_id!=""]
## protein coding
protein <- 
  gtf$gene_id[gtf$transcript_biotype %in% 
                  c("IG_C_gene", "IG_D_gene", "IG_J_gene", "IG_LV_gene", 
                    "IG_M_gene", "IG_V_gene", "IG_Z_gene", 
                    "nonsense_mediated_decay", "nontranslating_CDS", 
                    "non_stop_decay", 
                    "protein_coding", "TR_C_gene", "TR_D_gene", "TR_gene", 
                    "TR_J_gene", "TR_V_gene")]
## mitochondrial genes
mito <- gtf$gene_id[grepl("^mt\\-", gtf$gene_name) | 
                        gtf$transcript_biotype %in% c("Mt_tRNA", "Mt_rRNA")]
## long noncoding
lincRNA <- 
  gtf$gene_id[gtf$transcript_biotype %in% 
                  c("3prime_overlapping_ncrna", "lincRNA", 
                    "ncrna_host", "non_coding")]
## short noncoding
sncRNA <- 
  gtf$gene_id[gtf$transcript_biotype %in% 
                  c("miRNA", "miRNA_pseudogene", "misc_RNA", 
                    "misc_RNA_pseudogene", "Mt_rRNA", "Mt_tRNA", 
                    "Mt_tRNA_pseudogene", "ncRNA", "pre_miRNA", 
                    "RNase_MRP_RNA", "RNase_P_RNA", "rRNA", "rRNA_pseudogene", 
                    "scRNA_pseudogene", "snlRNA", "snoRNA", 
                    "snRNA_pseudogene", "SRP_RNA", "tmRNA", "tRNA",
                    "tRNA_pseudogene", "ribozyme", "scaRNA", "sRNA")]
## pseudogene
pseudogene <- 
  gtf$gene_id[gtf$transcript_biotype %in% 
                  c("disrupted_domain", "IG_C_pseudogene", "IG_J_pseudogene", 
                    "IG_pseudogene", "IG_V_pseudogene", "processed_pseudogene", 
                    "pseudogene", "transcribed_processed_pseudogene",
                    "transcribed_unprocessed_pseudogene", 
                    "translated_processed_pseudogene", 
                    "translated_unprocessed_pseudogene", "TR_J_pseudogene", 
                    "TR_V_pseudogene", "unitary_pseudogene", 
                    "unprocessed_pseudogene")]
danrer10.annotations <- list(protein=unique(protein), 
                             mito=unique(mito),
                             lincRNA=unique(lincRNA),
                             sncRNA=unique(sncRNA),
                             pseudogene=unique(pseudogene))
```
```{r echo=FALSE,include=FALSE,eval=TRUE}
danrer10.annotations <- readRDS(system.file("extdata", "danrer10.annotations.rds",
                                            package = "ribosomeProfilingQC"))
```

```{r}
library(ribosomeProfilingQC)
library(AnnotationDbi)
## prepare CDS annotation
txdb <- loadDb(system.file("extdata", "danRer10.chr1.txdb",
               package="ribosomeProfilingQC"))
CDS <- prepareCDS(txdb)

pc <- getPsiteCoordinates(bamfile, bestpsite = 13)
readsLengths <- 20:34
fl <- FLOSS(pc, ref = danrer10.annotations$protein, 
            CDS = CDS, readLengths=readsLengths, level="gene", draw = TRUE)
head(fl)
fl.max <- t(fl[c(1, which.max(fl$cooks.distance)), as.character(readsLengths)])
matplot(fl.max, type = "l", x=readsLengths, 
        xlab="Fragment Length", ylab="Fraction of Reads", 
        col = c("gray", "red"), lwd = 2, lty = 1)
legend("topright",  legend = c("ref", "selected gene"), 
       col = c("gray", "red"), lwd = 2, lty = 1)
```

# Prepare for downstream analysis

## RPFs only

### Count for RPFs
As we know, the P site is determined by arbitrary value 13 for quality control. 
For downstream analysis, we should adjust the reads to fit every reading frame located at 0.

```{r}
## filter the reads by fragment size
readsLen <- summaryReadsLength(pc)
(keep <- readsLenToKeep(readsLen))
pc.sub <- pc[pc$qwidth %in% keep]

pc.sub <- shiftReadsByFrame(pc.sub, txdb)
## test the result
plotDistance2Codon(pc.sub)
plotDistance2Codon(pc.sub, start=FALSE)
## P site distribution
table(pc.sub$Psite)
## motif for P site and A site
library(motifStack)
library(BSgenome.Drerio.UCSC.danRer10)
genome <- Drerio
PAmotif(pc.sub, genome)
```

Downstream analysis including differential analysis, comparison with RNAseq, and so on. 
Function `frameCounts` will generate a count vector for each transcript or gene, which can be used for differential analysis.

```{r}
cnts <- frameCounts(pc.sub)
head(cnts)
cnts.gene <- frameCounts(pc.sub, level="gene")
head(cnts.gene)
```

### Count for multiple RPFs

`countReads` can be used for count multiple files of ribo-seq.

```{r}
path <- system.file("extdata", package="ribosomeProfilingQC")
RPFs <- dir(path, "RPF.*?\\.[12].bam$", full.names=TRUE)
gtf <- file.path(path, "Danio_rerio.GRCz10.91.chr1.gtf.gz")
cnts <- countReads(RPFs, gtf=gtf, level="gene",
                   bestpsite=13, readsLen=c(28,29))
```

To get GTF file, you can download it from [ensembl](http://useast.ensembl.org/info/data/ftp/index.html)
or get the online file info via `AnnotationHub`.

```{r eval=FALSE}
BiocManager::install("AnnotationHub")
library(AnnotationHub)
ah = AnnotationHub()
## for human hg38
hg38 <- query(ah, c("Ensembl", "GRCh38", "gtf"))
hg38 <- hg38[length(hg38)]
gtf <- mcols(hg38)$sourceurl
## for mouse mm10
mm10 <- query(ah, c("Ensembl", "GRCm38", "gtf"))
mm10 <- mm10[length(mm10)]
gtf <- mcols(mm10)$sourceurl
```


### Differentail analysis only for RPFs

```{r}
library(edgeR)
gp <- c("KD1", "KD1", "KD2", "KD2", "WT", "WT")
y <- DGEList(counts = cnts$RPFs, group = gp)
y <- calcNormFactors(y)
design <- model.matrix(~0+gp)
colnames(design) <- sub("gp", "", colnames(design))
y <- estimateDisp(y, design)
## To perform quasi-likelihood F-tests:
fit <- glmQLFit(y, design)
contrast.matrix <- makeContrasts(contrasts = c("KD2-WT", "KD1-WT"), 
                                 levels=design)
qlf.KD2vsWT <- glmQLFTest(fit, contrast = contrast.matrix[, "KD2-WT"])
qlf.KD1vsWT <- glmQLFTest(fit, contrast = contrast.matrix[, "KD1-WT"])
topTags(qlf.KD2vsWT)
## To perform likelihood ratio tests:
fit <- glmFit(y, design)
lrt.KD2vsWT <- glmLRT(fit, contrast = contrast.matrix[, "KD2-WT"])
topTags(lrt.KD2vsWT)
```

### Alternative splicing, translation initiation and polyadenylation


```{r}
coverage <- coverageDepth(RPFs[grepl("KD1|WT", RPFs)], gtf=gtf, 
                          level="gene", region="feature with extension")
group1 <- c("RPF.KD1.1", "RPF.KD1.2")
group2 <- c("RPF.WT.1", "RPF.WT.2")
## subset the data
coverage <- lapply(coverage, function(.ele){ ## do not run this step for real data
  .ele$coverage <- lapply(.ele$coverage, `[`, i=seq.int(50))
  .ele$granges <- .ele$granges[seq.int(50)]
  .ele
})
se <- spliceEvent(coverage, group1, group2)
head(se)
table(se$type)
plotSpliceEvent(se, se$feature[1], coverage, group1, group2)
```


## RPFs and RNA-seq

### By counts

#### Count for RPFs and RNA-seq

`countReads` can be used for count multiple files of ribo-seq and RNA-seq.

```{r,eval=FALSE}
path <- system.file("extdata", package="ribosomeProfilingQC")
RPFs <- dir(path, "RPF.*?\\.[12].bam$", full.names=TRUE)
RNAs <- dir(path, "mRNA.*?\\.[12].bam$", full.names=TRUE)
gtf <- file.path(path, "Danio_rerio.GRCz10.91.chr1.gtf.gz")
## make sure that the order or RPFs is corresponded to RNAs.
cnts <- countReads(RPFs, RNAs, gtf, level="tx")
```
```{r,include=FALSE}
cnts <- readRDS(file.path(path, "cnts.rds"))
```


#### Translational Efficiency (TE)

Because the absolute level of ribosome occupancy is strongly correlated with RNA levels 
for both coding and noncoding transcripts, translational efficiency is introduced[@ingolia2009genome].
TE is the ratio of normalized ribosome footprint abundance to mRNA density.
A common normalization method is using Fragments Per Kilobase of transcript per Million mapped reads (FPKM).


```{r}
fpkm <- getFPKM(cnts)
TE <- translationalEfficiency(fpkm)
```

#### Differentail analysis for TE

We suppose that the log2 transformed translational efficiency that 
we calculated by the ratios of RPFs to mRNAs has linear correlation with real translational efficiency. 
We use _limma_ package to test the differential translational efficiency.

```{r}
library(limma)
gp <- c("KD1", "KD1", "KD2", "KD2", "WT", "WT")
TE.log2 <- log2(TE$TE + 1)
plot(TE.log2[, 1], TE.log2[, 5], 
     xlab=colnames(TE.log2)[1], ylab=colnames(TE.log2)[5],
     main="Translational Efficiency", pch=16, cex=.5)
design <- model.matrix(~0+gp)
colnames(design) <- sub("gp", "", colnames(design))
fit <- lmFit(TE.log2, design)
contrast.matrix <- makeContrasts(contrasts = c("KD2-WT", "KD1-WT"), 
                                 levels=design)
fit2 <- contrasts.fit(fit, contrasts = contrast.matrix)
fit2 <- eBayes(fit2)
topTable(fit2, coef = "KD2-WT")
```


### By coverage

#### Coverage ratio (CR)

Coverage is a measure as percentage of position with reads along the CDS. CR is the ratio of 
ribosome coverage to mRNA coverage. Coverage will be calculated based on the best P sites for RPFs 
and 5'end for RNA-seq.

```{r}
path <- system.file("extdata", package="ribosomeProfilingQC")
RPFs <- dir(path, "RPF.*?\\.[12].bam$", full.names=TRUE)
RNAs <- dir(path, "mRNA.*?\\.[12].bam$", full.names=TRUE)
gtf <- file.path(path, "Danio_rerio.GRCz10.91.chr1.gtf.gz")
```
```{r,eval=FALSE}
cvgs <- coverageDepth(RPFs, RNAs, gtf)
```
```{r, include=FALSE}
cvgs <- readRDS(file.path(path, "cvgs.rds"))
```
```{r}
cr <- coverageRates(cvgs)
plot(cr$mRNA[, 1], cr$RPFs[, 1], 
     xlab="coverage of mRNA", ylab="coverage of RPFs",
     main=colnames(cr$RPFs)[1], pch=16, cex=.5)
plot(cr$coverageRatio[, 1], cr$coverageRatio[, 5], 
     xlab=colnames(cr$coverageRatio)[1], ylab=colnames(cr$coverageRatio)[5],
     main="Coverage ratio", pch=16, cex=.5)
```

#### Maximum N-mer translational efficiency

If we plot the correlation of mRNAs or RPFs to translational efficiency that is 
calculated by all counts within a transcript,
we will find that TE is not well normalized. It shows higher values in low level transcripts 
while low values in high level transcripts.
```{r}
plotTE(TE, sample=2, xaxis="mRNA", log2=TRUE, pch=16, cex=.5)
plotTE(TE, sample=2, xaxis="RPFs", log2=TRUE, pch=16, cex=.5)
```

This issue can be fixed by calculating maximum value (TE max) in the most highly
ribosome-occupied 90 nt window within a feature[@ingolia2009genome].

```{r,eval=FALSE}
TE90 <- translationalEfficiency(cvgs, window = 90)
```
```{r,include=FALSE}
TE90 <- readRDS(file.path(path, "TE90.rds"))
```
```{r}
plotTE(TE90, sample=2, xaxis="mRNA", log2=TRUE, pch=16, cex=.5)
plotTE(TE90, sample=2, xaxis="RPFs", log2=TRUE, pch=16, cex=.5)
```

Above examples are TE90 for CDS region. Following codes show how to calculate TE90 for 3'UTR regions.

```{r,eval=FALSE}
cvgs.utr3 <- coverageDepth(RPFs, RNAs, gtf, region="utr3")
TE90.utr3 <- translationalEfficiency(cvgs.utr3, window = 90)
```
```{r,include=FALSE}
cvgs.utr3 <- readRDS(file.path(path, "cvgs.utr3.rds"))
TE90.utr3 <- readRDS(file.path(path, "TE90.utr3.rds"))
```
```{r}
plotTE(TE90.utr3, sample=2, xaxis="mRNA", log2=TRUE, pch=16, cex=.5)
plotTE(TE90.utr3, sample=2, xaxis="RPFs", log2=TRUE, pch=16, cex=.5)
```


#### Ribosome Release Score (RRS)

RRS is calculated as the ratio of RPFs (normalized by RNA-seq reads) in the CDS to RPFs in the 3'UTR.
Because it is hard to define the CDS region for non-coding RNAs, RRS can not be calculated by Function `ribosomeReleaseScore`.

```{r}
RRS <- ribosomeReleaseScore(TE90, TE90.utr3, log2 = TRUE)
plot(RRS[, 1], RRS[, 5],
     xlab="log2 transformed RRS of KD1", 
     ylab="log2 transformed RRS of WT1")
plot(RRS[, 1], log2(TE90$TE[rownames(RRS), 1]),
     xlab="log2 transformed RSS of KD1", 
     ylab="log2 transformed TE of KD1")
```

#### Metagene analysis plot

Plot metagene coverage for CDS, 5'UTR and 3'UTR.

```{r, eval=FALSE}
cvgs.utr5 <- coverageDepth(RPFs, RNAs, gtf, region="utr5")
```
```{r, include=FALSE}
cvgs.utr5 <- readRDS(file.path(path, "cvgs.utr5.rds"))
```

```{r}
metaPlot(cvgs.utr5, cvgs, cvgs.utr3, sample=2)
metaPlot(cvgs.utr5, cvgs, cvgs.utr3, sample=2, xaxis = "mRNA")
```


# References
